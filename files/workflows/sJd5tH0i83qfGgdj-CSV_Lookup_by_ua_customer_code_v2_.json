{
  "name": "CSV Lookup by ua_customer_code (v2)",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -544,
        -32
      ],
      "id": "a458af93-dc7c-4739-ac55-10dad0068e5c",
      "name": "When Executed by Another Workflow"
    },
    {
      "parameters": {
        "fields": {
          "values": [
            {
              "name": "code",
              "stringValue": "={{ $json.customer_code }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3,
      "position": [
        -352,
        -32
      ],
      "name": "Set Code Example2",
      "id": "5c46e2d2-4e77-4f90-b82f-46bd757ac0ab"
    },
    {
      "parameters": {
        "command": "=CODE=\"{{ $json.customer_code }}\"; awk -F';' -v code=\"$CODE\" 'NR==1{for(i=1;i<=NF;i++){h[i]=$i; gsub(/^\"|\"$/,\"\",h[i]); if(h[i]==\"ua_customer_code\") idx=i} if(!idx){print $0; next} print $0; next} { tmp=$idx; gsub(/^\"|\"$/,\"\",tmp); if(tmp==code || (tmp+0)==(code+0)) print $0 }' /files/transport_data_2025.csv"
      },
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        -144,
        -32
      ],
      "id": "f073f410-3e4e-4a63-8a3c-5a91590a5fac",
      "name": "Execute Command",
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// n8n Code node: parse stdout/binary CSV -> JSON items + binary CSV (with BOM for Excel)\n// Usage: connect Execute Command (or ReadBinaryFile) -> this Code node -> optional Write Binary File (to save CSV)\n// The node reads from $input.first().json.stdout or from $input.first().binary.data.data (base64).\n\ntry {\n  const raw = $input.first()?.json?.stdout ?? (\n    $input.first()?.binary?.data?.data\n      ? Buffer.from($input.first().binary.data.data, 'base64').toString('utf8')\n      : null\n  );\n\n  if (!raw) {\n    return [{ json: { error: 'no_input' } }];\n  }\n\n  // Normalize newlines\n  const text = raw.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n\n  // Robust CSV parser (handles quoted fields, doubled quotes, delimiter = ';')\n  function parseCSV(s, delimiter = ';') {\n    const rows = [];\n    let cur = '';\n    let row = [];\n    let inQuotes = false;\n    for (let i = 0; i < s.length; i++) {\n      const ch = s[i];\n      if (inQuotes) {\n        if (ch === '\"') {\n          if (i + 1 < s.length && s[i + 1] === '\"') {\n            cur += '\"';\n            i++;\n          } else {\n            inQuotes = false;\n          }\n        } else {\n          cur += ch;\n        }\n      } else {\n        if (ch === '\"') {\n          inQuotes = true;\n        } else if (ch === delimiter) {\n          row.push(cur);\n          cur = '';\n        } else if (ch === '\\n') {\n          row.push(cur);\n          cur = '';\n          rows.push(row);\n          row = [];\n        } else {\n          cur += ch;\n        }\n      }\n    }\n    if (cur !== '' || row.length > 0) {\n      row.push(cur);\n      rows.push(row);\n    }\n    return rows;\n  }\n\n  const rowsAll = parseCSV(text, ';');\n  if (!rowsAll || rowsAll.length === 0) {\n    return [{ json: { error: 'no_rows' } }];\n  }\n\n  // Header (keep original header text for CSV output, but create safe JSON keys)\n  const header = rowsAll.shift().map(h => (h ?? '').toString().trim());\n\n  function sanitizeKey(k, idx) {\n    if (!k || k.trim() === '') return `col_${idx + 1}`;\n    return k.trim().replace(/\\s+/g, '_').replace(/[^\\w\\-]/g, '_');\n  }\n  const keys = header.map((h, i) => sanitizeKey(h, i));\n\n  // Optional cleanup: strip trailing .0 from integer-looking numeric codes (e.g., \"5540209.0\" -> \"5540209\")\n  function cleanValue(v) {\n    if (v == null) return '';\n    const s = v.toString();\n    const trimmed = s.trim();\n    if (/^\\d+(\\.0+)?$/.test(trimmed)) return trimmed.replace(/\\.0+$/, '');\n    return trimmed;\n  }\n\n  // Build JSON items\n  const itemsJson = rowsAll.map(r => {\n    const obj = {};\n    for (let i = 0; i < keys.length; i++) {\n      obj[keys[i]] = (r[i] !== undefined) ? cleanValue(r[i]) : '';\n    }\n    return obj;\n  });\n\n  // Build CSV text again (quote fields when needed) and include BOM for Excel\n  function quoteField(f) {\n    if (f === null || f === undefined) return '';\n    const s = f.toString();\n    if (s.indexOf(';') !== -1 || s.indexOf('\"') !== -1 || s.indexOf('\\n') !== -1 || s.indexOf('\\r') !== -1) {\n      return '\"' + s.replace(/\"/g, '\"\"') + '\"';\n    }\n    return s;\n  }\n\n  const outLines = [ header.map(quoteField).join(';') ];\n  for (const r of rowsAll) {\n    const cols = [];\n    for (let i = 0; i < keys.length; i++) {\n      cols.push(quoteField((r[i] !== undefined) ? cleanValue(r[i]) : ''));\n    }\n    outLines.push(cols.join(';'));\n  }\n  const csvText = outLines.join('\\r\\n') + '\\r\\n';\n  const csvBase64 = Buffer.from('\\uFEFF' + csvText, 'utf8').toString('base64'); // BOM added\n\n  // Pick a sensible filename: prefer incoming $input.first().json.code if present, else 'matches'\n  const codeVal = $input.first()?.json?.code ?? itemsJson[0]?.ua_customer_code ?? 'result';\n  const filename = `matches_${codeVal}.csv`;\n\n  // Prepare output: first element contains binary CSV (for Write Binary File), then JSON items\n  const output = [];\n\n  // summary + binary on first element\n  output.push({\n    json: {\n      _summary: {\n        row_count: itemsJson.length,\n        filename\n      },\n      // put first row also inside json for convenience if you need it\n      first_row: itemsJson.length ? itemsJson[0] : null\n    },\n    binary: {\n      data: {\n        data: csvBase64,\n        fileName: filename,\n        mimeType: 'text/csv; charset=utf-8'\n      }\n    }\n  });\n\n  // remaining JSON rows as separate items (useful for Spreadsheet/Google Sheets nodes)\n  for (let i = 0; i < itemsJson.length; i++) {\n    output.push({ json: itemsJson[i] });\n  }\n\n  return output;\n} catch (err) {\n  return [{ json: { error: true, message: err.message, stack: err.stack } }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        112,
        -32
      ],
      "id": "08632fc4-09ba-480c-acb1-0781fc284d89",
      "name": "Code in JavaScript"
    }
  ],
  "pinData": {},
  "connections": {
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "Set Code Example2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Code Example2": {
      "main": [
        [
          {
            "node": "Execute Command",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Command": {
      "main": [
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        []
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "7cfb7de1-ff54-400e-ab4d-b22ceef3407f",
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "id": "sJd5tH0i83qfGgdj"
}